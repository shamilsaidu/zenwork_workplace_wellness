import cohere from '../config/cohere.js';
import JournalModel from '../models/journalModel.js';
import userModel from '../models/userModel.js';

// Helper function to parse NLP patterns from analysis
const parseNLPPatterns = (analysisText) => {
    const patterns = {
        absoluteLanguage: 0,
        negativeFraming: 0,
        discountingPositives: 0,
        mindReading: 0,
        achievements: 0
    };

    // Simple heuristic analysis - in a real app you'd use more sophisticated NLP
    if (analysisText.includes('absolute language') || analysisText.includes('universal quantifiers')) {
        patterns.absoluteLanguage = 1;
    }
    if (analysisText.includes('negative framing') || analysisText.includes('negative language')) {
        patterns.negativeFraming = 1;
    }
    if (analysisText.includes('discounting') || analysisText.includes('dismissing')) {
        patterns.discountingPositives = 1;
    }
    if (analysisText.includes('assume') || analysisText.includes('mind reading')) {
        patterns.mindReading = 1;
    }
    if (analysisText.includes('achievement') || analysisText.includes('success')) {
        patterns.achievements = 1;
    }

    return patterns;
};

export const analyzeJournalEntry = async (req, res) => {
    try {
        const { userId, entry } = req.body;

        if (!entry || entry.trim().length === 0) {
            return res.status(400).json({ 
                success: false, 
                message: "Journal entry cannot be empty" 
            });
        }

        // Get user data
        const user = await userModel.findById(userId);
        if (!user) {
            return res.status(404).json({ 
                success: false, 
                message: "User not found" 
            });
        }

        // Generate structured analysis using Cohere
        const analysisResponse = await cohere.generate({
            model: "command",
            prompt: `Analyze this workplace journal entry for ${user.name} using NLP principles. Provide a JSON response with these fields:
            {
                "languagePatterns": {
                    "absoluteTerms": [array of examples],
                    "modalOperators": [array of examples],
                    "suggestedReframes": [array of suggested alternatives]
                },
                "cognitivePatterns": {
                    "distortions": [array of identified cognitive distortions],
                    "examples": [array of specific examples from text]
                },
                "relationships": {
                    "positiveInteractions": [array],
                    "challengingInteractions": [array],
                    "suggestions": [array of improvement suggestions]
                },
                "achievements": [array of positive accomplishments noted],
                "actionableSteps": [array of 3-5 concrete NLP techniques to try]
            }
            Journal entry: ${entry.substring(0, 2000)}`,
            maxTokens: 500,
            temperature: 0.7,
        });

        if (!analysisResponse.generations || analysisResponse.generations.length === 0) {
            throw new Error('No analysis generated by Cohere');
        }

        let structuredAnalysis;
        try {
            // Extract JSON from the response
            const jsonString = analysisResponse.generations[0].text.match(/\{[\s\S]*\}/)?.[0] || '{}';
            structuredAnalysis = JSON.parse(jsonString);
        } catch (e) {
            console.error('Failed to parse analysis JSON:', e);
            structuredAnalysis = { error: "Could not parse analysis" };
        }

        // Get sentiment score
        const sentimentResponse = await cohere.generate({
            model: "command",
            prompt: `Rate the sentiment of this journal entry from 1-10 (1=negative, 10=positive). Return ONLY the number.
                    Entry: ${entry.substring(0, 1000)}`,
            maxTokens: 2,
            temperature: 0.3,
        });

        let sentimentScore = 5;
        if (sentimentResponse.generations?.[0]) {
            const scoreText = sentimentResponse.generations[0].text.trim();
            const parsedScore = parseInt(scoreText);
            if (!isNaN(parsedScore)) {
                sentimentScore = Math.min(10, Math.max(1, parsedScore));
            }
        }

        // Auto-tag based on content
        const tags = [];
        if (entry.toLowerCase().includes('workload') || entry.toLowerCase().includes('busy')) tags.push('workload');
        if (entry.toLowerCase().includes('team') || entry.toLowerCase().includes('colleague')) tags.push('relationships');
        if (entry.toLowerCase().includes('achieve') || entry.toLowerCase().includes('success')) tags.push('achievement');
        if (entry.toLowerCase().includes('stress') || entry.toLowerCase().includes('overwhelm')) tags.push('stress');

        // Save to database
        const journalEntry = await JournalModel.create({
            userId,
            entry,
            analysis: structuredAnalysis,
            sentimentScore,
            tags,
            nlpPatterns: parseNLPPatterns(analysisResponse.generations[0].text)
        });

        // Update user's journal entries
        await userModel.findByIdAndUpdate(userId, {
            $push: { journalEntries: journalEntry._id }
        });

        res.status(201).json({
            success: true,
            message: "Journal entry analyzed successfully",
            journalEntry: {
                _id: journalEntry._id,
                entry: journalEntry.entry,
                analysis: journalEntry.analysis,
                sentimentScore: journalEntry.sentimentScore,
                tags: journalEntry.tags,
                nlpPatterns: journalEntry.nlpPatterns,
                createdAt: journalEntry.createdAt
            }
        });

    } catch (error) {
        console.error('Journal analysis error:', error);
        res.status(500).json({ 
            success: false, 
            message: error.message || 'Failed to analyze journal entry',
            error: process.env.NODE_ENV === 'development' ? error.stack : undefined
        });
    }
};

export const getJournalEntries = async (req, res) => {
    try {
        const { userId } = req.body;

        const entries = await JournalModel.find({ userId })
            .sort({ createdAt: -1 })
            .select('entry analysis sentimentScore tags nlpPatterns createdAt');

        // Calculate comprehensive insights
        const insights = {
            sentiment: {
                average: entries.reduce((acc, curr) => acc + curr.sentimentScore, 0) / (entries.length || 1),
                positiveDays: entries.filter(e => e.sentimentScore >= 7).length,
                challengingDays: entries.filter(e => e.sentimentScore <= 4).length,
                trend: calculateSentimentTrend(entries)
            },
            patterns: {
                absoluteLanguage: entries.reduce((acc, curr) => acc + (curr.nlpPatterns?.absoluteLanguage || 0), 0),
                negativeFraming: entries.reduce((acc, curr) => acc + (curr.nlpPatterns?.negativeFraming || 0), 0),
                achievements: entries.reduce((acc, curr) => acc + (curr.nlpPatterns?.achievements || 0), 0)
            },
            tags: countTags(entries),
            commonThemes: entries.length > 0 ? await analyzeCommonThemes(entries) : []
        };

        res.status(200).json({
            success: true,
            entries,
            insights
        });

    } catch (error) {
        console.error('Get entries error:', error);
        res.status(500).json({ 
            success: false, 
            message: error.message || 'Failed to get journal entries'
        });
    }
};

// Helper functions
function calculateSentimentTrend(entries) {
    if (entries.length < 2) return 'neutral';
    const recent = entries.slice(0, 2);
    const diff = recent[0].sentimentScore - recent[1].sentimentScore;
    return diff > 1 ? 'improving' : diff < -1 ? 'declining' : 'stable';
}

function countTags(entries) {
    const tagCounts = {};
    entries.forEach(entry => {
        entry.tags?.forEach(tag => {
            tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
    });
    return tagCounts;
}

const analyzeCommonThemes = async (entries) => {
    try {
        const entryTexts = entries.map(e => e.entry).join('\n\n');
        const response = await cohere.generate({
            model: "command",
            prompt: `Identify the top 3 recurring themes in these journal entries. For each, provide:
                    - The theme name
                    - Frequency (high/medium/low)
                    - One suggestion for improvement
                    Return as a JSON array:
                    [{
                        "theme": "theme name",
                        "frequency": "high/medium/low",
                        "suggestion": "improvement suggestion"
                    }]
                    Entries: ${entryTexts.substring(0, 5000)}`,
            maxTokens: 300,
            temperature: 0.5,
        });

        if (!response.generations?.[0]?.text) return [];
        
        try {
            const jsonString = response.generations[0].text.match(/\[[\s\S]*\]/)?.[0] || '[]';
            return JSON.parse(jsonString);
        } catch (e) {
            console.error('Failed to parse themes JSON:', e);
            return [];
        }
    } catch (error) {
        console.error('Theme analysis error:', error);
        return [];
    }
};

// New endpoint for NLP action tracking
export const trackNLPAction = async (req, res) => {
    try {
        const { userId, action, completed } = req.body;
        
        await userModel.findByIdAndUpdate(userId, {
            $push: { 
                nlpActions: {
                    action,
                    completed: completed || false,
                    date: new Date()
                }
            }
        });

        res.status(200).json({
            success: true,
            message: "NLP action tracked successfully"
        });
    } catch (error) {
        console.error('Track action error:', error);
        res.status(500).json({ 
            success: false, 
            message: error.message || 'Failed to track NLP action'
        });
    }
};